<?php

use Illuminate\Database\Eloquent\Model;
use Model\FriendlyUrl;

/**
 * Class BaseModel
 *
 * Extend this to create a new model type.
 * You must at minimum override the following three values:
 * - protected $table = The table name
 * - protected $attributes = an array of columns in "column" => "defaultvalue" or "column" => ["defaultvalue", "missing message"] form
 * - protected $fillable = a whitelist array of editable columns
 * That's it!
 */
abstract class BaseModel extends Model {

    public $dateFormat = "U";
    const ERROR_URL = "That URL is already used by another page, please choose a different URL.";
    const IMAGES_FOLDER = 'assets/images';
    const DOCUMENTS_FOLDER = 'assets/documents';

    /**
     * Flag to indicate whether our model is going to be validating itself on save.
     *
     * @var boolean
     */
    public static $autoValidate = true;

    protected $requiredMessages = [];

    /**
     * Errors returned from our last validation attempt.
     *
     * @var array
     */
    protected $errors = [];

    public function __construct($attributes = []){
        $this->parseAttributes();
        parent::__construct($attributes);
    }

    /**
     * Returns an input builder to build standardized input fields on admin templates
     *
     * @param $property
     *
     * @return InputBuilder
     */
    public function input($property){
        return new InputBuilder($this, $property);
    }


    /**
     * Returns an input group builder to build standardized input fields in a group.
     * This is a simple wrapper for multiple inputs that adds the necessary clearfix classes
     * And handles adding a label and a wrapped classes if a label() method is used
     *
     * @param $properties       string[]
     *
     * @return InputGroupBuilder
     */
    public function inputGroup($properties){
        return new InputGroupBuilder($this, $properties);
    }

    /**
     * Returns a new InputTabGroupBuilder to start building a group of tabs.
     * The first argument is an array of InputTabs generated by $this->inputTab()
     *
     * @param InputTab[]        $tabs           An array of InputTab objects generated by $this->inputTab()
     * @param string            $groupName      An optional group name (useful when there are multiple tab groups on the same page)
     *
     * @return InputTabGroupBuilder
     */
    public function inputTabGroup($tabs, $groupName = "tabs"){
        return new InputTabGroupBuilder($tabs, $groupName);
    }

    /**
     * Returns a new InputTab for this object
     *
     * @param $name
     * @param $function
     *
     * @return InputTab
     */
    public function inputTab($name, $function){
        return new InputTab($this, $name, $function);
    }

    /**
     * FRIENDLY URL SETTINGS
     * By turning friendlyUrls on, upon creation or save, this model will save its friendlyURL and
     * route information to the friendlyURL table.
     *
     * The route will be defined as:
     * /controller/method/id
     *
     * So with these default settings it would route to
     * /events/details/this->id
     */
    /** @var bool Whether this should save friendly urls */
    protected $usesFriendlyURLs = false;
    /** @var string The controller this should route its friendly urls to */
    public $friendlyURLController = "basemodel";
    /** @var string The method this should route its friendly urls to */
    protected $friendlyURLMethod = "basemodel";
    /** @var string The index column used  */
    protected $friendlyURLID = "id";
    /** @var string The field to auto-derive friendly urls from */
    public $friendlyURLDeriveFrom = "title";

    /**
     * Image upload settings
     */
    /** @var array List of fields that should upload images into */
    protected $imageFields = [];
    /** @var string The sub-directory in images where images should go */
    public $imageFolder = "basemodel";

    protected $pdfFields = [];
    public $pdfFolder = "basemodel";

    protected $skipValidation = false;
    //TODO Why do we have skip validation and autovalidate?

    /**
     * Fetches a model by ID
     *
     * @param $id
     *
     * @return BaseModel
     */
    public static function getById($id){
        return static::where("id", $id)->first();
    }

    /**
     * Parses the attribute list in case we've entered in an array of values like
     * name = ["", "Please enter your name"]
     * in the form of
     * column = ["default value", "Message in case empty"]
     *
     * If the message slot is missing, then it's assumed OK to use the default value
     */
    protected function parseAttributes(){
        foreach($this->attributes as $key => &$value){
            if(is_array($value)){
                if(count($value) > 1){
                    $this->requiredMessages[$key] = $value[1];
                }
                $value = $value[0];
            }
        }
    }

    /**
     * Override the model's bootstrap function to insert our custom events for the system.
     */
    protected static function boot() {
        parent::boot();

        static::created(function($model){
            return $model->postCreate();
        });

        static::saving(function($model) {
            if ($model::$autoValidate) {
                if (!$model->validate())
                    return false;
            }
            return $model->preSave();
        });

        static::saved(function($model) {
            $model->postSave();
            return true;
        });

        static::deleted(function($model) {
            $model->postDelete();
            return true;
        });
    }

    /**
     * ABSTRACTED METHODS
     *
     * Please ONLY use these methods or else you'll be interacting with the installed ORM directly
     * And we should only use abstracted methods so we can de-couple from the current ORM if necessary
     */
    public static function get(){
        if(Input::get("sort")){
            $query = static::orderBy(Input::get("sort"), Input::get("direction") == "desc" ? true : false);
            if($query->count()){
                return $query->get();
            } else {
                return [];
            }
        }
        return static::all();
    }

    public function __get($what){
        return parent::__get($what);
    }

    public function __set($key, $value){
        parent::__set($key, $value);
    }

    public function getError($key){
        if(isset($this->errors[$key])) return $this->errors[$key];
        return '';
    }

    public function setValues($attributes){
        $purifier = new HTMLPurifier();

        foreach($this->imageFields as $field){
            $uploaded = $this->uploadImageInto($field, $this->imageFolder);
            if($uploaded){
                $attributes[$field] = $uploaded;
            }
        }

        foreach($this->pdfFields as $field){
            $uploaded = $this->uploadPdfInto($field, $this->pdfFolder);
            if($uploaded){
                $attributes[$field] = $uploaded;
            }
        }

        foreach($this->fillable as $key){
            if(array_key_exists($key, $attributes)) {
                $this->{$key} = $attributes[$key];
            }
        }

        $this->setCustomValues();
    }

    protected function setCustomValues(){

    }

    /**
     * Check the validity of our current attributes. Usually is called
     * automatically before a save, but can be called manually.
     *
     * @return bool
     */
    public function validate() {
        if($this->skipValidation) return true;

        foreach($this->attributes as $key => $value){
            if(isset($this->requiredMessages[$key]) && strlen($this->requiredMessages[$key])){
                if(!strlen($this->{$key})){
                    $error = $this->requiredMessages[$key];
                    $this->errors[$key] = $error;
                } else {
                    $this->errors[$key] = null;
                }
            }
        }
        return $this->hasErrors() ? false : true;
    }

    /**
     * Perform any data alterations or additional checks before we commit
     * to the database. Child classes can abort the save by returning a
     * value of false.
     *
     * @return bool
     */
    public function preSave() {
        $this->castForDatabase();

        // check if this friendly url is ok to use
        if($this->usesFriendlyURLs){
            $friendlyUrlBase = in_array(Input::post("friendlyurl"), ['']) ? $this->{$this->friendlyURLDeriveFrom} : Input::post("friendlyurl");
            $friendUrlFront = "/".$this->friendlyURLController."/";
            $friendlyUrlToUse = str_replace($friendUrlFront,"",$friendlyUrlBase);
            $friendlyUrlToUse = $friendUrlFront . $friendlyUrlToUse;
            $route = implode("/", array($this->friendlyURLController, $this->friendlyURLMethod, $this->{$this->friendlyURLID}));
            if(!FriendlyUrl::isURLAvailable($route, $friendlyUrlToUse)){
                $this->errors['friendlyurl'] = static::ERROR_URL;
                return false;
            }
        }

        // update created and updated


        if(!$this->validate()){
            return false;
        }
        return true;
    }

    /**
     * Prepare current values for readabiblity
     */
    public function postCreate(){

    }

    /**
     * Prepare current values for saving to DB
     */
    public function castForDatabase(){

    }

    public function postDelete(){
        if($this->usesFriendlyURLs){
            $route = implode("/", array("", $this->friendlyURLController, $this->friendlyURLMethod, $this->{$this->friendlyURLID}));
            FriendlyUrl::deactivate($route, $this->friendlyURLController);
        }
    }

    /**
     * Perform any processing necessary after this record's data has been
     * committed to the database. There is no way to abort or cancel the
     * commit at this point.
     */
    public function postSave() {
        if($this->usesFriendlyURLs){
            $friendlyUrlBase = in_array(Input::post("friendlyurl"), ['']) ? $this->{$this->friendlyURLDeriveFrom} : Input::post("friendlyurl");
            // $friendUrlFront = "/".$this->friendlyURLController."/";
            // $friendlyUrlToUse = str_replace($friendUrlFront,"",$friendlyUrlBase);
            // $friendlyUrlToUse = $friendUrlFront . $friendlyUrlToUse;
            $friendlyUrlToUse = $friendlyUrlBase;
            $route = implode("/", array($this->friendlyURLController, $this->friendlyURLMethod, $this->{$this->friendlyURLID}));
            FriendlyUrl::addOrIgnore($route, $friendlyUrlToUse, $this->friendlyURLController);
        }
    }

    /**
     * Returns the friendlyurl as a string if we're using friendly urls
     * Returns null if route not found or if we're not using friendly urls
     *
     * @return string | null
     */
    public function getFriendlyUrl(){
        if($this->usesFriendlyURLs){
            $route = implode("/", array($this->friendlyURLController, $this->friendlyURLMethod, $this->{$this->friendlyURLID}));
            $model = FriendlyUrl::getByRoute($route);
            return $model ? $model->friendlyurl : null;
        } else {
            return null;
        }
    }

    /**
     * Return the errors from our last save attempt.
     *
     * @return array
     */
    public function getErrors() {
        // add an index for each field

        foreach($this->attributes as $key => $value){
            if(!isset($this->errors[$key])) $this->errors[$key] = null;
        }
        return $this->errors;
    }

    public function hasErrors(){
        // return true if any error slots are not empty
        foreach($this->errors as $key => $value){
            if(!is_array($value) && $value !== null){
                return true;
            } else if(is_array($value)){
                foreach($value as $key2 => $value2){
                    if($value2 != null) return true;
                }
            }
        }
        return false;
    }

//TODO This should dispaly a stand error block and error message should come in as a varaiable passed with the text below as a default
    public function printErrors(){
        if(count($this->errors)){
            $output = '<a name="emailresponse" style="display: block; margin-bottom: 180px;"></a><div class="errmsg"><div><h3>Please confirm the following and try submitting again.</h3><ul>';
            foreach($this->errors as $section => $error){
                if(strlen($error)) $output .= '<li>' . $error . '</li>';
            }
            $output .= '</ul></div></div>';
            return $output;
        } else {
            return '';
        }
    }

    /**
     * Indicates whether a specified attribute exists in this model.
     *
     * @param string $key Attribute to check
     * @return bool True is this model has the specified attribute
     */
    public function hasAttribute($key) {
        return array_key_exists($key, $this->attributes);
    }


//TODO Care to explain?
    public function uploadMultiImageInto($field, $i, $imageFolder){
        if(!isset($field)){
            return false;
        }
        $imageUpload = new \ImageUpload(SYSTEM_DIR . "/assets/images/partials/$imageFolder/");

        $fileData = [];
        foreach($field as $part => $data){
            $fileData[$part] = $data[$i];
        }

        if($imageUpload->process($fileData)) {
            return $imageUpload->getCurrentName();
        } else {
            return false;
        }
    }

//TODO Care to explain?  Do we really need mutiple and single?
    public function uploadImageInto($field, $imageFolder){
        // first check if we're trying to auto-delete this field
        if(Input::post("delete_$field") == 1){
            $this->$field = '';

        } else { // if not, continue with the upload

            // kick back false if this file hasn't been uploaded
            if (!isset($_FILES[$field])) {
                return false;
            }

            // otherwise; upload
            $imageUpload = new \ImageUpload(SYSTEM_DIR . "/". static::IMAGES_FOLDER ."/$imageFolder/$this->directory/");
            if ($imageUpload->process($_FILES[$field])) {
                return $imageUpload->getCurrentName();
            } else {
                return false;
            }
        }
    }

//TODO Care to explain?
    public function uploadSingleFileInto($fileArray, $i, $imageFolder){
        if(!isset($fileArray)){
            return false;
        }

        $file = $fileArray[$i];

        $dirToUploadTo = SYSTEM_DIR . "/". static::IMAGES_FOLDER ."/$imageFolder/";
        $imageUpload = new \ImageUpload($dirToUploadTo);
        if($imageUpload->process($file)) {
            return $imageUpload->getCurrentName();
        } else {
            return false;
        }
    }

//TODO Care to explain?  Do we really need mutiple and single?
    public function uploadImageFileInto($fileArray, $i, $imageFolder){
        if(!isset($fileArray)){
            return false;
        }

        $file = [];
        foreach($fileArray as $name => $val){
            $file[$name] = $val[$i];
        }

        $dirToUploadTo = SYSTEM_DIR . "/" . static::IMAGES_FOLDER . "/$imageFolder/";
        $imageUpload = new \ImageUpload($dirToUploadTo);
        if($imageUpload->process($file)) {
            return $imageUpload->getCurrentName();
        } else {
            return false;
        }
    }

    //TODO Care to explain should this be labled mutiple?
    public function uploadPdfFileInto($fileArray, $i, $pdfFolder = "/pdfs/"){
        if(!isset($fileArray)){
            return false;
        }

        $file = [];
        foreach($fileArray as $name => $val){
            $file[$name] = $val[$i];
        }

        $dirToUploadTo = SYSTEM_DIR . $pdfFolder;
        $pdfUpload = new FileUpload($dirToUploadTo);
        if($pdfUpload->process($file)) {
            return $pdfUpload->getCurrentName();
        } else {
            return false;
        }
    }

    //TODO Care to explain?  Do we really need mutiple and single?
    public function uploadPdfInto($field, $pdfFolder){
        if(Input::post("delete_$field") == 1){
            $this->$field = '';

        } else {
            if (!empty($_FILES[$field]["name"]) && empty($err)) {
                // Process uploaded file.
                $filename = $_FILES[$field]["name"];
                $tmpname = $_FILES[$field]["tmp_name"];
                $destdir = '';

                // Set directory and file paths.
                // Generate new filename.
                $fileExists = true;
                $addnum = 1;
                $addname = "";
                while ($fileExists) {
                    // Base the new filename off the old filename, but with slight modification.
                    $newfilename = substr(basename($filename, ".pdf"), 0, 245);
                    $newfilename = preg_replace("/\\s/", "_", $newfilename); // No spaces!
                    $newfilename = preg_replace("/[^-_a-z0-9.]/i", "", $newfilename); // Only these chars allowed...
                    $newfilename .= $addname; // For gaurenteeing uniqueness.
                    $newfilename .= ".pdf";

                    // Set destination paths based on new filenames.
                    $destdir = SYSTEM_DIR . "/assets/documents/" . $pdfFolder;
                    $destpath = $destdir . "/" . $newfilename;

                    // See if file exists.
                    $fileExists = is_file($destpath);
                    $addname = "-$addnum";
                    $addnum++;
                }

                // Make sure the main directory and temp directory exist and can be written to.
                if (!is_dir($destdir) || !is_writable($destdir)) {
                    $err[] = "PDF directory not found or not writable: $destdir";
                }

                // Check the filename.
                if (empty($err)) {
                    if (!preg_match("/^(.*)\.pdf$/i", $filename)) {
                        $err[] = "Invalid file format: The PDF must have a \".pdf\" filename extension.";
                    } else {
                        // Move the uploaded file to a temporary location.
                        if (!move_uploaded_file($tmpname, $destpath)) {
                            $err[] = "Error uploading file to $destpath";
                        } else {
                            return $newfilename;
                        }
                    }
                }
            }
        }
    }


    //TODO Care to explain?
    public function formatTime($key = 'time', $readable = true){
        if(is_numeric($this->{$key})) {
            $format = $readable ? "g:i A" : "g:i A";
            $time = $this->{$key};

            return date($format, $time);
        } else {
            return $this->{$key};
        }
    }

    //TODO Care to explain?
    public function formatDate($key = 'date', $readable = true){
        if(is_numeric($this->{$key})){
            $format = $readable ? "Y-m-d" : "n/j/Y";
            $date = $this->{$key};

            return date($format, $date);
        } else {
            return $this->{$key};
        }
    }

    /** Sets this model to the last in its group by ordering by $displayOrderField */
    public function setOrderToLast($displayOrderField){
        if(isset($this->$displayOrderField) && strlen($this->$displayOrderField)) {
            $this->{$displayOrderField} = static::count() + 1;
        }
    }

    /**
     * Returns oneToMany relationship.
     * Currently maps to eloquent hasMany function
     *
     * @param string $class
     * @param null|string $foreignKey
     * @param null|string $localKey
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function hasMany($class, $foreignKey = null, $localKey = null){
        return parent::hasMany($class, $foreignKey, $localKey);
    }

    /**
     * @param $class
     * @param null $table
     * @param null $localKey
     * @param null $foreignKey
     * @param null $thisKey
     * @param array $pivotColumns
     *
     * @return $this|\Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function manyToMany($class, $table = null, $localKey = null, $foreignKey = null, $thisKey = null, $pivotColumns = []){
        $result = parent::belongsToMany($class, $table, $localKey, $foreignKey, $thisKey);
        return count($pivotColumns) ? $result->withPivot($pivotColumns) : $result;
    }
}